<html>
<head>
    <title>Math Game</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/style.css">
    <script src="lib/pixi.js"></script>
    <script src="lib/kotlin.js"></script>
    <script src="lib/twf.js"></script>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <script type="text/javascript">
        const canvas = document.getElementById("mainCanvas");
        const renderer = new PIXI.Renderer({
            view: canvas,
            resolution: 1
        });

        var style = new PIXI.TextStyle({
            fontFamily: 'Comic Sans MS',
            fontSize: 24,
            fill: 0xffffff
        })

        var extraSettings = {
            divisionLineExtraLength: 4,    // used for managing "multi-floor" fractions
            divisionLineWidth: 3,   // division line thickness
            powerOffsetMultiplier: 2/3  // managing base Y axis offset relatively to power height
        }

        //var testTaskString = "a*(a+b/c)/24";
        //var testTaskString = "a+(a+b/c+d/(e))/24";
        //var testTaskString = "a+b+c/d";
        //var testTaskString = "a-b-c";
        //var testTaskString = "a+(b/(c-12))/24";
        //var testTaskString = "a+(b/(c-12))/(24/48)";
        //var testTaskString = "a*b*c/d";
        //var testTaskString = "a*b*(c/d)";
        //var testTaskString = "a^b";

        var testTaskString = "a*b*((c/d)/e)^f";
        var expressionRoot = twf.api.stringToExpression(testTaskString);    // will need to parse an expressionString in the future
        var containerRoot = outputReactiveExpression(expressionRoot);
        console.log(expressionRoot);
        console.log(containerRoot);

        animate();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(containerRoot);
        }

        function outputReactiveExpression(expressionNode) {
            var outputContainer = makeReactiveExpression(0, 0, expressionNode);
            outputContainer.position.set((renderer.width-outputContainer.width)/2, (renderer.height-outputContainer.height)/2);
            return outputContainer;
        }

        function makeReactiveExpression(x, y, expressionNode) {
            var container = new PIXI.Container();
            container.x = x;
            container.y = y;
            var children = expressionNode.children.array_hd7ov6$_0;
            var type = expressionNode.nodeType.name$;
            var value = expressionNode.value;
            container.expressionTreeNodeId = expressionNode.nodeId;
            if (type === "VARIABLE") {  // ATTENTION: currently implies not having children
                var text = new PIXI.Text(value, style);
                container.addChild(text);
                return makeResponsiveContainer(container);
            }
            else if (type === "FUNCTION") {
                switch(value) {
                    case "+":
                        var curOffset = 0;
                        var maxHeight = 0;
                        var parts = [];
                        var plus_signs = [];
                        var childrenAmount = expressionNode.children.array_hd7ov6$_0.length;
                        for (childNum = 0; childNum < childrenAmount; childNum++) {
                            var newBlock = makeReactiveExpression(curOffset, 0, expressionNode.children.array_hd7ov6$_0[childNum]);
                            curOffset += newBlock.width;
                            maxHeight = Math.max(maxHeight, newBlock.height);
                            parts.push(newBlock);

                            if (childNum < childrenAmount-1) {
                                if (expressionNode.children.array_hd7ov6$_0[childNum+1].value !== "-") { // if right child is -(<some_expression>), then we shouldn't draw a "+"
                                    var text = new PIXI.Text("+", style);
                                    text.position.set(curOffset, 0);
                                    plus_signs.push(text);
                                    var textBlockWidth = PIXI.TextMetrics.measureText("+", style).width;
                                    curOffset += textBlockWidth;
                                }
                            }
                        }
                        
                        for (let part of parts) {
                            part.y = (maxHeight-part.height)/2;
                            container.addChild(part);
                        }
                        for (let sign of plus_signs) {
                            sign.y = (maxHeight-sign.height)/2;
                            container.addChild(sign);
                        }
                        return makeResponsiveContainer(container);

                    case "-":
                        var text = new PIXI.Text("-", style);
                        text.position.set(0, 0);
                        var textBlockWidth = PIXI.TextMetrics.measureText("-", style).width;
                        var variable_part = makeReactiveExpression(textBlockWidth, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        
                        container.addChild(text);
                        container.addChild(variable_part);
                        break;

                    case "*":
                        var curOffset = 0;
                        var maxHeight = 0;
                        var parts = [];
                        var multiply_signs = [];
                        var childrenAmount = expressionNode.children.array_hd7ov6$_0.length;
                        for (childNum = 0; childNum < childrenAmount; childNum++) {
                            var newBlock = makeReactiveExpression(curOffset, 0, expressionNode.children.array_hd7ov6$_0[childNum]);
                            curOffset += newBlock.width;
                            maxHeight = Math.max(maxHeight, newBlock.height);
                            parts.push(newBlock);

                            if (childNum < childrenAmount-1) {
                                var text = new PIXI.Text("*", style);
                                text.position.set(curOffset, 0);
                                multiply_signs.push(text);
                                var textBlockWidth = PIXI.TextMetrics.measureText("*", style).width;
                                curOffset += textBlockWidth;
                            }
                        }
                        
                        for (let part of parts) {
                            part.y = (maxHeight-part.height)/2;
                            container.addChild(part);
                        }
                        for (let sign of multiply_signs) {
                            sign.y = (maxHeight-sign.height)/2;
                            container.addChild(sign);
                        }
                        return makeResponsiveContainer(container);

                    case "/":
                        var numerator = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        var denominator = makeReactiveExpression(0, numerator.height+extraSettings.divisionLineWidth, expressionNode.children.array_hd7ov6$_0[1]);

                        var fractionLength = Math.max(numerator.width, denominator.width)+extraSettings.divisionLineExtraLength;
                        var fractionHeight = numerator.width+numerator.height+extraSettings.divisionLineWidth;
                        var numeratorOffset = (fractionLength-numerator.width)/2;
                        var denominatorOffset = (fractionLength-denominator.width)/2;
                        numerator.x += numeratorOffset;
                        denominator.x += denominatorOffset;

                        var divisionLine = new PIXI.Graphics();
                        divisionLine.lineStyle(extraSettings.divisionLineWidth, 0xffffff);
                        divisionLine.moveTo(0, numerator.height);
                        divisionLine.lineTo(fractionLength, numerator.height);
                        divisionLine.closePath();

                        container.addChild(numerator);
                        container.addChild(denominator);
                        container.addChild(divisionLine);
                        return makeResponsiveContainer(container);
                    
                    case "^":
                        var base = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        var power = makeReactiveExpression(base.width, 0, expressionNode.children.array_hd7ov6$_0[1]);
                        base.y = power.height*extraSettings.powerOffsetMultiplier;

                        container.addChild(base);
                        container.addChild(power);
                        return makeResponsiveContainer(container);

                    default:    // ATTENTION: currectly means only full expression (what if brackets?)
                        var fullContainer = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        container.addChild(fullContainer);
                        return container;
                }
            }
        }

        function makeResponsiveContainer(container) {
            container.interactive = true;
            container.buttonMode = true;
            container.hitArea = new PIXI.Rectangle(0, 0, container.width, container.height);
            container.on("click", returnNodeId);
            var highlightRect = new PIXI.Graphics();
            highlightRect.lineStyle(0, 0xffffff);
            highlightRect.beginFill(0xffffff);
            highlightRect.drawRect(0, 0, container.width, container.height);
            highlightRect.endFill();
            highlightRect.alpha = 0;

            // TODO: make only the deepest selected node highlighted and reactive
            container.mouseover = function(mouseData) {
                highlightRect.alpha = 0.4;
            }

            container.mouseout = function(mouseData) {
                highlightRect.alpha = 0;
            }

            function returnNodeId() {
                console.log(container.expressionTreeNodeId);    // for testing purposes
            }

            container.addChild(highlightRect);
            return container;
        }
    </script>
</body>
</html>