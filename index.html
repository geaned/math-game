<html>
<head>
    <title>Math Game</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="css/style.css">
    <script src="lib/pixi.js"></script>
    <script src="lib/kotlin.js"></script>
    <script src="lib/twf.js"></script>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <script type="text/javascript">
        const canvas = document.getElementById("mainCanvas");
        const renderer = new PIXI.Renderer({
            view: canvas,
            resolution: 1
        });

        var style = new PIXI.TextStyle({
            fontFamily: 'Comic Sans MS',
            fontSize: 24,
            fill: 0xffffff
        })

        var extraSettings = {
            divisionLineExtraLength: 4,    // used for managing "multi-floor" fractions
            divisionLineWidth: 3,   // division line thickness
            powerOffsetMultiplier: 2/3  // managing base Y axis offset relatively to power height
        }

        function isInBlock(pointerX, pointerY, boxX, boxY, boxWidth, boxHeight) {
            if (pointerX >= boxX && pointerX <= boxX + boxWidth && pointerY >= boxY && pointerY <= boxY + boxHeight)
                return true;
            else
                return false;
        }

        //var testTaskString = "a*(a+b/c)/24";
        //var testTaskString = "a+(a+b/c+d/(e))/24";
        //var testTaskString = "a+b+c/d";
        //var testTaskString = "a-b-c";
        //var testTaskString = "a+(b/(c-12))/24";
        //var testTaskString = "a+(b/(c-12))/(24/48)";
        //var testTaskString = "a*b*c/d";
        //var testTaskString = "a*b*(c/d)";
        //var testTaskString = "a^b";
        //var testTaskString = "a*b*((c/d)/e)^f";
        //var testTaskString = "sin(a)";
        var testTaskString = "cos((a/(b+12))/(e+123)+c)";

        var expressionRoot = twf.api.stringToExpression(testTaskString);    // will need to parse an expressionString in the future (just change the command)
        var containerRoot = outputReactiveExpression(expressionRoot);
        var config = new twf.config.CompiledConfiguration();
        var kek = twf.api.expressionSubstitutionFromStructureStrings("a", "b", void 0, void 0, void 0); // change name ASAP
        config.compiledExpressionTreeTransformationRules.array_hd7ov6$_0 = [kek];  // fake rule for testing purposes
        config.compiledExpressionTreeTransformationRules.modCount = config.compiledExpressionTreeTransformationRules.array_hd7ov6$_0.length;
        console.log(expressionRoot);
        console.log(containerRoot);
        console.log(config);

        animate();

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(containerRoot);
        }

        function outputReactiveExpression(expressionNode) {
            var outputContainer = makeReactiveExpression(0, 0, expressionNode);
            var absoluteCoordStartX = (renderer.width-outputContainer.width)/2;
            var absoluteCoordStartY = (renderer.height-outputContainer.height)/2;
            outputContainer.position.set(absoluteCoordStartX, absoluteCoordStartY);

            outputContainer.nodeData = getAllNodeBlocksCoords(outputContainer, [], 0, 0);

            outputContainer.interactive = true;
            outputContainer.buttonMode = true;
            outputContainer.hitArea = new PIXI.Rectangle(0, 0, outputContainer.width, outputContainer.height);
            outputContainer.on("click", getDeepestContainer);

            var nodeAmount = outputContainer.nodeData.length;
            function getDeepestContainer(event) {
                var posX = event.data.global.x;
                var posY = event.data.global.y;
                console.log([posX, posY]);
                var deepestContainerClicked = 0;
                for (nodeNum = 0; nodeNum < nodeAmount; nodeNum++) {
                    if (isInBlock(posX, posY, outputContainer.nodeData[nodeNum].x, outputContainer.nodeData[nodeNum].y, outputContainer.nodeData[nodeNum].width, outputContainer.nodeData[nodeNum].height) &&
                        outputContainer.nodeData[nodeNum].nodeId > deepestContainerClicked) {
                        deepestContainerClicked = outputContainer.nodeData[nodeNum].nodeId;
                    }
                }
                console.log(deepestContainerClicked);   // IMPORTANT: deepest selected node's id
            }
            return outputContainer;
        }

        function makeReactiveExpression(x, y, expressionNode) {
            var container = new PIXI.Container();
            container.x = x;
            container.y = y;
            var children = expressionNode.children.array_hd7ov6$_0;
            var type = expressionNode.nodeType.name$;
            var value = expressionNode.value;
            container.expressionTreeNodeId = expressionNode.nodeId;
            if (type === "VARIABLE") {  // ATTENTION: currently implies not having children
                var text = new PIXI.Text(value, style);
                container.addChild(text);
                return makeResponsiveContainer(container);
            }
            else if (type === "FUNCTION") {
                switch(value) {
                    case "+":
                        var curOffset = 0;
                        var maxHeight = 0;
                        var parts = [];
                        var plus_signs = [];
                        var childrenAmount = expressionNode.children.array_hd7ov6$_0.length;
                        for (childNum = 0; childNum < childrenAmount; childNum++) {
                            var newBlock = makeReactiveExpression(curOffset, 0, expressionNode.children.array_hd7ov6$_0[childNum]);
                            curOffset += newBlock.width;
                            maxHeight = Math.max(maxHeight, newBlock.height);
                            parts.push(newBlock);

                            if (childNum < childrenAmount-1) {
                                if (expressionNode.children.array_hd7ov6$_0[childNum+1].value !== "-") { // if right child is -(<some_expression>), then we shouldn't draw a "+"
                                    var text = new PIXI.Text("+", style);
                                    text.position.set(curOffset, 0);
                                    plus_signs.push(text);
                                    var textBlockWidth = PIXI.TextMetrics.measureText("+", style).width;
                                    curOffset += textBlockWidth;
                                }
                            }
                        }
                        
                        for (let part of parts) {
                            part.y = (maxHeight-part.height)/2;
                            container.addChild(part);
                        }
                        for (let sign of plus_signs) {
                            sign.y = (maxHeight-sign.height)/2;
                            container.addChild(sign);
                        }
                        return makeResponsiveContainer(container);

                    case "-":
                        var text = new PIXI.Text("-", style);
                        text.position.set(0, 0);
                        var textBlockWidth = PIXI.TextMetrics.measureText("-", style).width;
                        var variable_part = makeReactiveExpression(textBlockWidth, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        
                        container.addChild(text);
                        container.addChild(variable_part);
                        break;

                    case "*":
                        var curOffset = 0;
                        var maxHeight = 0;
                        var parts = [];
                        var multiply_signs = [];
                        var childrenAmount = expressionNode.children.array_hd7ov6$_0.length;
                        for (childNum = 0; childNum < childrenAmount; childNum++) {
                            var newBlock = makeReactiveExpression(curOffset, 0, expressionNode.children.array_hd7ov6$_0[childNum]);
                            curOffset += newBlock.width;
                            maxHeight = Math.max(maxHeight, newBlock.height);
                            parts.push(newBlock);

                            if (childNum < childrenAmount-1) {
                                var text = new PIXI.Text("*", style);
                                text.position.set(curOffset, 0);
                                multiply_signs.push(text);
                                var textBlockWidth = PIXI.TextMetrics.measureText("*", style).width;
                                curOffset += textBlockWidth;
                            }
                        }
                        
                        for (let part of parts) {
                            part.y = (maxHeight-part.height)/2;
                            container.addChild(part);
                        }
                        for (let sign of multiply_signs) {
                            sign.y = (maxHeight-sign.height)/2;
                            container.addChild(sign);
                        }
                        return makeResponsiveContainer(container);

                    case "/":
                        var numerator = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        var denominator = makeReactiveExpression(0, numerator.height+extraSettings.divisionLineWidth, expressionNode.children.array_hd7ov6$_0[1]);

                        var fractionLength = Math.max(numerator.width, denominator.width)+extraSettings.divisionLineExtraLength;
                        var fractionHeight = numerator.width+numerator.height+extraSettings.divisionLineWidth;
                        var numeratorOffset = (fractionLength-numerator.width)/2;
                        var denominatorOffset = (fractionLength-denominator.width)/2;
                        numerator.x += numeratorOffset;
                        denominator.x += denominatorOffset;

                        var divisionLine = new PIXI.Graphics();
                        divisionLine.lineStyle(extraSettings.divisionLineWidth, 0xffffff);
                        divisionLine.moveTo(0, numerator.height);
                        divisionLine.lineTo(fractionLength, numerator.height);
                        divisionLine.closePath();

                        container.addChild(numerator);
                        container.addChild(denominator);
                        container.addChild(divisionLine);
                        return makeResponsiveContainer(container);
                    
                    case "^":
                        var base = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                        var power = makeReactiveExpression(base.width, 0, expressionNode.children.array_hd7ov6$_0[1]);
                        base.y = power.height*extraSettings.powerOffsetMultiplier;

                        container.addChild(base);
                        container.addChild(power);
                        return makeResponsiveContainer(container);

                    default:    // ATTENTION: currectly means only unary mathematical functions which are not operators
                        if (value === "") {     // ATTENTION: this currently only means full expression
                            var fullContainer = makeReactiveExpression(0, 0, expressionNode.children.array_hd7ov6$_0[0]);
                            container.addChild(fullContainer);
                            return container;

                        } else {
                            var left_side = new PIXI.Text(value+"(", style);
                            var textBlockWidth = PIXI.TextMetrics.measureText(value+"(", style).width;
                            var textBlockHeight = PIXI.TextMetrics.measureText(value+"(", style).height;

                            var operand = makeReactiveExpression(textBlockWidth, 0, expressionNode.children.array_hd7ov6$_0[0]);
                            var heightOffset = (operand.height-textBlockHeight)/2;
                            left_side.position.set(0, heightOffset);

                            var right_side = new PIXI.Text(")", style);
                            right_side.position.set(textBlockWidth+operand.width, heightOffset);

                            container.addChild(left_side);
                            container.addChild(right_side);
                            container.addChild(operand);
                            return makeResponsiveContainer(container);
                        }
                        
                }
            }
        }

        function makeResponsiveContainer(container) {
            container.interactive = true;
            container.buttonMode = true;
            container.hitArea = new PIXI.Rectangle(0, 0, container.width, container.height);
            var highlightRect = new PIXI.Graphics();
            highlightRect.lineStyle(0, 0xffffff);
            highlightRect.beginFill(0xffffff);
            highlightRect.drawRect(0, 0, container.width, container.height);
            highlightRect.endFill();
            highlightRect.alpha = 0;

            // TODO: make only the deepest selected node highlighted and reactive + hightling of overlapping zones works wacky
            container.mouseover = function(mouseData) {
                highlightRect.alpha = 0.4;
            }

            container.mouseout = function(mouseData) {
                highlightRect.alpha = 0;
            }

            container.addChild(highlightRect);
            return container;
        }

        function getAllNodeBlocksCoords(container, NodeDataArray, absoluteCoordX, absoluteCoordY) {
            if (container.hasOwnProperty('expressionTreeNodeId')) {
                NodeDataArray.push({
                    nodeId: container.expressionTreeNodeId,
                    x: absoluteCoordX+container.x,
                    y: absoluteCoordY+container.y,
                    width: container.width,
                    height: container.height
                });
                for (let child of container.children) {
                    NodeDataArray = getAllNodeBlocksCoords(child, NodeDataArray, absoluteCoordX+container.x, absoluteCoordY+container.y);
                }
            }
            return NodeDataArray;
        }
    </script>
</body>
</html>